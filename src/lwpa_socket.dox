Whoa, this isn't a real source file! What's going on here? Well, the sources
for this module are platform-specific, so the functions are documented here to
avoid repeating documentation in each source file.

/*! \addtogroup lwpa_socket
 *  @{
 */

/*! A socket handle. Typedefed to the system's socket identifier. */
typedef UNDEFINED lwpa_socket_t;

/*! An identifier for an invalid socket handle. */
#define LWPA_SOCKET_INVALID

/*! @} */

/*! \brief Initialize the lwpa_socket module.
 *
 *  Some platforms require initialization before socket/networking
 *  functionality can be used. Others do not, and on those platforms this will
 *  simply be an empty function. This function can be called multiple times in
 *  a given application, but it must be paired with an equal number of calls to
 *  lwpa_socket_deinit().
 *
 *  \param[in] platform_data A pointer to platform-specific data to use on
 *                           initialization. The specific type is defined in
 *                           lwpa_socket_[platform].h if it exists for a
 *                           platform. NULL indicates use defaults.
 *  \return #LWPA_OK: Initialization successful.\n
 *          #LWPA_SYSERR: An internal library or system call error occurred.\n
 */
lwpa_error_t lwpa_socket_init(void *platform_data);

/*! \brief Deinitialize the lwpa_socket module.
 *
 *  Some platforms require deinitialization when an application is finished
 *  using socket/networking functionality. Others do not, and on those
 *  platforms this will simply be an empty function. This function must be
 *  called for every time that lwpa_socket_init() is called in an application.
 */
void lwpa_socket_deinit();

/*! \brief Accept a connection on a socket.
 *
 *  Refer to your favorite accept() man page for more information.
 *
 *  Differences from POSIX: addrlen parameter is omitted because there is only
 *  one lwpa sockaddr type. Connected socket is returned in an output parameter
 *  rather than the return value.
 *
 *  \param[in] id Listening socket on which to accept a new connection.
 *  \param[out] address Remote address from which the connection was accepted.
 *  \param[out] conn_sock Filled in on success with handle to connected socket.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (failure).
 */
lwpa_error_t lwpa_accept(lwpa_socket_t id, LwpaSockaddr *address,
                         lwpa_socket_t *conn_sock);

/*! \brief Bind a name to a socket.
 *
 *  Refer to your favorite bind() man page for more information.
 *
 *  Differences from POSIX: addrlen parameter is omitted because there is only
 *  one lwpa sockaddr type.
 *
 *  \param[in] id Socket to which to bind an address (traditionally called a
 *                'name').
 *  \param[in] address Address to assign to the socket.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_bind(lwpa_socket_t id, const LwpaSockaddr *address);

/*! \brief Close a socket.
 *
 *  Refer to your favorite close() man page for more information.
 *
 *  On UNIX-like systems, note that this may also successfully close
 *  descriptors that don't refer to sockets; however, for portability it should
 *  only be used on identifiers that were returned from an lwpa_* function.
 *
 *  \param[in] id Socket to close.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_close(lwpa_socket_t id);

/*! \brief Initiate a connection on a socket.
 *
 *  Refer to your favorite connect() man page for more information.
 *
 *  Differences from POSIX: addrlen parameter is omitted because there is only
 *  one lwpa sockaddr type.
 *
 *  \param[in] id Socket to connect.
 *  \param[in] address Address to which to connect.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_connect(lwpa_socket_t id, const LwpaSockaddr *address);

/*! \brief Get the name of the connected peer socket.
 *
 *  Refer to your favorite getpeername() man page for more information.
 *
 *  Differences from POSIX: addrlen parameter is omitted because there is only
 *  one lwpa sockaddr type.
 *
 *  \param[in] id Connected socket for which to get the peer address.
 *  \param[in] address Filled in with peer address on success.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_getpeername(lwpa_socket_t id, LwpaSockaddr *address);

/*! \brief Get socket name.
 *
 *  Refer to your favorite getsockname() man page for more information.
 *
 *  Differences from POSIX: addrlen parameter is omitted because there is only
 *  one lwpa sockaddr type.
 *
 *  \param[in] id Connected socket for which to get the bound address.
 *  \param[in] address Filled in with bound address on success.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_getsockname(lwpa_socket_t id, LwpaSockaddr *address);

/*! \brief Get an option value for a socket.
 *
 *  Refer to your favorite getsockopt() man page for more information.
 *
 *  Differences from POSIX: Some overlapping option values are consolidated and
 *  some legacy option values are not included. Some value types are different;
 *  see the documentation of each possible option value.
 *
 *  \param[in] id Socket for which to get the option value.
 *  \param[in] level Protocol level of the option for which to get the value.
 *  \param[in] option_name Name of the option for which to get the value.
 *  \param[out] option_value Filled in with option value on success.
 *  \param[in,out] option_len Contains size of buffer pointed to by
 *                            option_value, filled in with actual size of value
 *                            returned.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_getsockopt(lwpa_socket_t id, int level, int option_name,
                    void *option_value, size_t *option_len);

/*! \brief Listen for connections on a socket.
 *
 *  Refer to your favorite listen() man page for more information.
 *
 *  \param[in] id LWPA_STREAM socket on which to listen.
 *  \param[in] backlog Maximum length of pending connection queue.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_listen(lwpa_socket_t id, int backlog);

/*! \brief Receive data on a connected socket.
 *
 *  Refer to your favorite recv() man page for more information.
 *
 *  \param[in] id Socket on which to receive.
 *  \param[out] buffer Buffer in which to place received data.
 *  \param[in] length Size in bytes of buffer.
 *  \param[in] flags Receive flags.
 *  \return Number of bytes received (success) or lwpa_error_t code from system
 *          (error occurred).
 */
int lwpa_recv(lwpa_socket_t id, void *buffer, size_t length, int flags);

/*! \brief Receive data on a socket.
 *
 *  Refer to your favorite recvfrom() man page for more information.
 *
 *  Differences from POSIX: addrlen parameter is omitted because there is only
 *  one lwpa sockaddr type.
 *
 *  \param[in] id Socket on which to receive.
 *  \param[out] buffer Buffer in which to place received data.
 *  \param[in] length Size in bytes of buffer.
 *  \param[in] flags Receive flags.
 *  \param[out] address If provided, filled in on success with peer address
 *                      from which the data was received.
 *  \return Number of bytes received (success) or lwpa_error_t code from system
 *          (error occurred).
 */
int lwpa_recvfrom(lwpa_socket_t id, void *buffer, size_t length, int flags,
                  LwpaSockaddr *address);

/*! \brief Send data on a connected socket.
 *
 *  Refer to your favorite send() man page for more information.
 *
 *  Differences from POSIX: Returns int rather than nonstandard ssize_t.
 *
 *  \param[in] id Socket on which to send.
 *  \param[in] message Message to send.
 *  \param[in] length Size in bytes of message.
 *  \param[in] flags Send flags.
 *  \return Number of bytes sent (success) or lwpa_error_t code from system
 *          (error occurred).
 */
int lwpa_send(lwpa_socket_t id, const void *message, size_t length, int flags);

/*! \brief Send data on a socket.
 *
 *  Refer to your favorite sendto() man page for more information.
 *
 *  Differences from POSIX: Returns int rather than nonstandard ssize_t.
 *  addrlen parameter is omitted because there is only one lwpa sockaddr type.
 *
 *  \param[in] id Socket on which to send.
 *  \param[in] message Message to send.
 *  \param[in] length Size in bytes of message.
 *  \param[in] flags Send flags.
 *  \param[in] dest_addr Address to which to send the message.
 *  \return Number of bytes sent (success) or lwpa_error_t code from system
 *          (error occurred).
 */
int lwpa_sendto(lwpa_socket_t id, const void *message, size_t length, int flags,
                const LwpaSockaddr *dest_addr);

/*! \brief Set an option value on a socket.
 *
 *  Refer to your favorite setsockopt() man page for more information.
 *
 *  Differences from POSIX: Some overlapping option values are consolidated and
 *  some legacy option values are not included. Some value types are different;
 *  see the documentation of each possible option value.
 *
 *  \param[in] id Socket for which to set the option value.
 *  \param[in] level Protocol level of the option for which to set the value.
 *  \param[in] option_name Name of the option for which to set the value.
 *  \param[out] option_value Value to set for the option.
 *  \param[in,out] option_len Size of value pointed to by option_value.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error occurred).
 */
lwpa_error_t lwpa_setsockopt(lwpa_socket_t id, int level, int option_name,
                    const void *option_value, size_t option_len);

/*! \brief Shut down part of a full-duplex connection.
 *
 *  Refer to your favorite shutdown() man page for more information.
 *
 *  \param[in] id Socket to be shut down.
 *  \param[in] how How to shut down the socket, one of the LWPA_SHUT_* values.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_shutdown(lwpa_socket_t id, int how);

/*! \brief Create a socket.
 *
 *  Refer to your favorite socket() man page for more information.
 *
 *  Differences from POSIX: Rarely-used 'protocol' parameter is omitted.
 *  #LWPA_SOCKET_INVALID is the only invalid return value.
 *
 *  \param[in] family Protocol family that the socket should use.
 *  \param[in] type Socket communication type.
 *  \return #LWPA_SOCKET_INVALID (error occurred) or a value other than
 *          #LWPA_SOCKET_INVALID (success).
 */
lwpa_socket_t lwpa_socket(unsigned int family, unsigned int type);

/*! \brief Change the blocking behavior of a socket.
 *
 *  This is similar to manipulating the O_NONBLOCK flag through the fcntl()
 *  function on a BSD socket.
 *
 *  \param[in] id Socket for which to change the blocking behavior.
 *  \param[in] blocking true (socket should block) or false (socket should not
 *                      block).
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (error
 *          occurred).
 */
lwpa_error_t lwpa_setblocking(lwpa_socket_t id, bool blocking);

/*! \brief Wait for some event on a set of sockets.
 *
 *  Refer to your favorite poll() man page for more information.
 *
 *  On UNIX-like systems, note that this may also work for descriptors that
 *  don't refer to sockets; however, for portability it should only be used on
 *  identifiers that were returned from an lwpa_* function.
 *
 *  \param[in,out] fds Set of socket descriptors to be monitored.
 *  \param[in] nfds Number of LwpaPollfd structs in the fds array.
 *  \param[in] timeout_ms How long to wait for an event, in milliseconds. Use
 *                        #LWPA_WAIT_FOREVER to wait indefinitely.
 *  \return Number of LwpaPollfd structs which have nonzero revents fields
 *          (success), #LWPA_TIMEDOUT (timed out), or other lwpa_error_t value
 *          from the underlying system call (error occurred).
 */
int lwpa_poll(LwpaPollfd *fds, size_t nfds, int timeout_ms);

/*! \brief Get address information for a named internet host and/or service.
 *
 *  Refer to your favorite getaddrinfo() man page for more information. One
 *  difference between this and the POSIX function is the way that multiple
 *  addresses are iterated. lwpa uses the lwpa_nextaddr() function instead of a
 *  next pointer to iterate over multiple addresses. For example:
 *
 *  \code
 *  LwpaAddrinfo info;
 *  if (0 == lwpa_getaddrinfo("www.google.com", "http", NULL, &info))
 *  {
 *    do
 *    {
 *      char inet_str[LWPA_INET6_ADDRSTRLEN];
 *      if (LWPA_OK == lwpa_inet_ntop(&info.ai_addr.ip, inet_str,
 *                                    LWPA_INET6_ADDRSTRLEN))
 *      {
 *        printf("Address: %s\n", inet_str);
 *      }
 *      else
 *        printf("Address conversion error!\n");
 *
 *    } while (lwpa_nextaddr(&info));
 *
 *    lwpa_freeaddrinfo(&info);
 *  }
 *  \endcode
 *
 *  On an internet-connected machine with DNS resolution capability, the above
 *  code should print something like:
 *  \code
 *  Address: 172.217.4.196
 *  Address: 172.217.4.196
 *  Address: 2607:f8b0:4009:806::2004
 *  Address: 2607:f8b0:4009:806::2004
 *  \endcode
 *
 *  \param[in] hostname Either a string-represented numerical network address
 *                      or a network hostname to resolve.
 *  \param[in] service Either a string-represented numerical port number or a
 *                     service name.
 *  \param[in] hints Structure containing hints restricting the address types
 *                   that can be returned.
 *  \param[out] result On success, filled in with the first address result.
 *  \return #LWPA_OK (success) or lwpa_error_t code from system (an error
 *          occurred).
 */
lwpa_error_t lwpa_getaddrinfo(const char *hostname, const char *service,
                              const LwpaAddrinfo *hints, LwpaAddrinfo *result);

/*! \brief Get the next address from the list returned by lwpa_getaddrinfo().
 *
 *  Most platforms allocate and return a linked list of address info structs
 *  in their getaddrinfo() implementation. To avoid further memory allocation
 *  in the abstraction layer, this non-POSIX-like way to iterate through the
 *  addrinfo structs is provided. To get all of the addresses returned from a
 *  lwpa_getaddrinfo() call, keep calling this on the result struct until it
 *  returns false.
 *
 *  \param[in,out] ai Pointer to last lwpa_addrinfo struct, filled in with
 *                    values of the next address.
 *  \return true (next address was filled in) or false (no more addresses or
 *          error).
 */
bool lwpa_nextaddr(LwpaAddrinfo *ai);

/*! \brief Free an addrinfo list returned by lwpa_getaddrinfo().
 *
 *  Most platforms allocate memory when getaddrinfo() is called. This must
 *  always be called after any call to lwpa_getaddrinfo() to free that memory.
 *  It can be called with any of the LwpaAddrinfo instances in the
 *  list, and the whole list will be freed. See the example usage in the
 *  description of lwpa_getaddrinfo().
 *
 *  \param[in] ai Pointer to lwpa_addrinfo struct for which to free the
 *                platform memory.
 */
void lwpa_freeaddrinfo(LwpaAddrinfo *ai);

/*! \brief Convert IPv4 and IPv6 addresses from binary to text form.
 *
 *  Refer to your favorite inet_ntop() man page for more information.
 *
 *  Differences from POSIX: af parameter is omitted because that information is
 *  contained in the struct lwpa_ip.
 *
 *  \param[in] src Address to convert to string form.
 *  \param[out] dest Filled in on success with the string-represented address.
 *  \param[in] size Size in bytes of dest buf.
 *  \return #LWPA_OK: Success.\n
 *          #LWPA_INVALID: Invalid parameter.\n
 *          #LWPA_SYSERR: System call failed.
 */
lwpa_error_t lwpa_inet_ntop(const LwpaIpAddr *src, char *dest, size_t size);

/*! \brief Convert IPv4 and IPv6 addresses from text to binary form.
 *
 *  Refer to your favorite inet_pton() man page for more information.
 *
 *  Differences from POSIX: lwpa_iptype_t used instead of AF_* value, since
 *  this function is only used for IP addresses.
 *
 *  \param[in] type Type of string-represented IP address pointed to by src.
 *  \param[in] src Character string containing a string-represented IP address.
 *  \param[out] dest Filled in on success with the address.
 *  \return #LWPA_OK: Success.\n
 *          #LWPA_INVALID: Invalid parameter.\n
 *          #LWPA_SYSERR: System call failed.
 */
lwpa_error_t lwpa_inet_pton(lwpa_iptype_t type, const char *src,
                            LwpaIpAddr *dest);
